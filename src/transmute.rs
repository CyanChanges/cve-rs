//! An 100% memory-safe implementation of [`std::mem::transmute`].

use std::mem::{self, ManuallyDrop};

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`], but implemented in safe code.
///
/// # Explanation
///
/// This transmute implementation relies on what I call "Enum abuse" â€” exploiting the memory representation of enums (+ other UB) in Rust to achieve silly things.
///
/// The core of the exploit is this enum:
///
/// ```ignore
/// enum DummyEnum<A, B> {
///     A(Option<Box<A>>),
///     B(Option<Box<B>>),
/// }
/// ```
///
/// First, we initialize a `DummyEnum::B(None)` and we get a dangling `&mut Option<Box<B>>` from it.
/// Then, we overwrite the dummy variable with a `DummyEnum::A(Some(<...>))` with the object we want to transmute.
/// Finally, we take the `Box<A>`, interpreted as a `Box<B>`, out of the dangling reference and we've transmuted our data!
///
/// # Safety
/// lol
///
pub fn transmute_old<A, B>(obj: A) -> B {
	use std::hint::black_box;

	// The layout of `DummyEnum` is approximately
	// DummyEnum {
	//     is_a_or_b: u8,
	//     data: usize,
	// }
	// Note that `data` is shared between `DummyEnum::A` and `DummyEnum::B`.
	// This should hopefully be more reliable than spamming the stack with a value and hoping the memory
	// is placed correctly by the compiler.
	enum DummyEnum<A, B> {
		A(Option<Box<A>>),
		B(Option<Box<B>>),
	}

	#[inline(never)]
	fn transmute_inner<A, B>(dummy: &mut DummyEnum<A, B>, obj: A) -> B {
		let DummyEnum::B(ref_to_b) = dummy else {
			unreachable!()
		};
		let ref_to_b = crate::lifetime_expansion::expand_mut(ref_to_b);
		*dummy = DummyEnum::A(Some(Box::new(obj)));
		black_box(dummy);

		*ref_to_b.take().unwrap()
	}

	transmute_inner(black_box(&mut DummyEnum::B(None)), obj)
}

/// Similar to [`core::option::Option`], but aligned to `T` and `T2`. Used to create
/// options that are always the exact same size, so they can be transmuted into each
/// other. Inspired by LawrenceEsswood's code:
/// https://github.com/Speykious/cve-rs/issues/13#issuecomment-1958160725
///
/// # Why this is Needed
/// This requires a lot of context. The bug we exploit allows us to completely bypass
/// Rust's type system in safe code. It's a severe bug, but rustc has no issues with
/// the final code when compiling, since it is a bug. Unfortunately, LLVM *also* has
/// type checking, and the bug we exploit doesn't bypass LLVM's type system. This Rust
/// code will compile down to a cast between types in the LLVM assembly; however, in
/// some cases, LLVM does not allow the types involved to be cast to each other. To
/// get around this, we need to reliably use two types that can be cast to each other.
/// The easiest way to do this is to use pointers, since pointers can always be cast to
/// each other. We can't use raw pointers in safe Rust, but we can use borrows/references,
/// which will compile down to pointers in the LLVM assembly, and thus can be cast
/// without errors.
///
/// So, basically, we *have* to transmute borrows of data, and not the raw data itself,
/// or it'll sometimes fail to compile (depending on the types being transmuted). This
/// creates an issue, though; for non-copy types, you can't get owned data back from
/// a borrow, it's stuck as a borrow. This means our transmute function can only transmute
/// borrows, and never work with owned data, which would mean it doesn't work exactly the
/// same as [`core::mem::transmute`]. The solution to this is to use [`core::mem::take`],
/// which allows you to take the data from a mutable reference and replace it with the
/// default data instead. This gives you ownership of the old data. However, not all types
/// we transmute have [`Default`] implemented, so we can't just use `take` with any data.
///
/// This is where [`Option`] comes in. The default value for an option is `None`, which
/// doesn't have to store any data. This means you can use `take` with *any* data, just
/// by wrapping it in an option; you take the data from `Some`, and replace it with `None`,
/// which doesn't require you to generate any data. So, basically, to get around LLVM errors
/// and the borrow checker, we actually transmute `&mut Option<T>`; this creates a pointer,
/// which LLVM is okay with casting, and borrow that can be taken with [`core::mem::take`]
/// to get back the owned data.
///
/// There is, however, one last issue, with Rust's optimisations and type alignments. For
/// some types in Rust, there are *invalid states* that cannot be reached. For example,
/// a borrow can never be null, since it always points to valid data, and null pointers
/// are never valid. Thus, Rust can represent `Option::None` as that invalid state, because
/// `Some(T)` will never use it. This means that options are not always the same size.
/// Furthermore, types are aligned based on their own size, so when we transmute between
/// types of different sizes, there can sometimes be size and alignment issues that cause
/// the program to break. `AlignedOption` solves this issue; it serves the same purpose as
/// a regular `Option`, as described above, but forces the data to be aligned for two types
/// by being `#[repr(C)]` and storing data from the first type as well as a zero-length array
/// of the second type.
///
/// So, to recap, we can transmute between types by using our type system exploit with an
/// `&mut AlignedOption<T1, T2>`. Using the reference prevents casting errors in LLVM. Because
/// it's mutable, and `AlignedOption` has a default value, we can use it with [`core::mem::take`]
/// to get the owned data back from the reference. And because this type is aligned for `T1` and `T2`,
/// we avoid alignment or size issues from Rust's optimisations.
#[repr(C)]
enum AlignedOption<T, T2> {
	None,
	Some(T, [T2; 0]),
}
impl<T, T2> Default for AlignedOption<T, T2> {
	fn default() -> Self {
		Self::None
	}
}

trait Object<T> {
	type Input;
}
impl<T: ?Sized, T2> Object<T2> for T {
	type Input = T2;
}

fn exploit<I, O>(val: I) -> O {
	fn _inner<T: ?Sized, T2>(val: <T as Object<T2>>::Input) -> T2 {
		val
	}

	_inner::<dyn Object<O, Input = I>, O>(val)
}

trait Trans<T> {
	fn cast(self) -> T;
	fn cast_ref(&self) -> &T;
	fn cast_mut(&mut self) -> &mut T;
}
impl<T, T2> Trans<T2> for T {
	fn cast(self) -> T2 {
		// ManuallyDrop prevents `self` from being dropped, since it's being transmuted. Otherwise we get a double-free
		// and `val` will have random data.
		let mut aligned_self = ManuallyDrop::new(AlignedOption::Some::<T, T2>(self, []));
		let val: &mut AlignedOption<T2, T> = exploit(&mut aligned_self);

		let AlignedOption::Some(val, _) = mem::take(val) else {
			unreachable!()
		};
		val
	}
	fn cast_ref(&self) -> &T2 {
		exploit(self)
	}
	fn cast_mut(&mut self) -> &mut T2 {
		exploit(self)
	}
}

#[inline(always)]
pub fn transmute<I, O>(val: I) -> O {
	val.cast()
}
#[inline(always)]
pub fn transmute_ref<I, O>(val: &I) -> &O {
	val.cast_ref()
}
#[inline(always)]
pub fn transmute_mut<I, O>(val: &mut I) -> &mut O {
	val.cast_mut()
}

#[cfg(test)]
mod tests {
	// I'll allow it here.
	#![allow(unsafe_code)]

	use crate::transmute::Trans;

	#[derive(Debug, Clone)]
	struct MyStruct {
		field: bool,
		field2: u16,
		field3: String,
		field4: &'static str,
	}
	#[derive(Debug)]
	struct OtherStruct {
		field: bool,
		field2: u16,
		field3: String,
		field4: &'static str,
	}
	impl PartialEq<OtherStruct> for MyStruct {
		fn eq(&self, other: &OtherStruct) -> bool {
			self.field == other.field
				&& self.field2 == other.field2
				&& self.field3 == other.field3
				&& self.field4 == other.field4
		}
	}

	#[test]
	#[allow(clippy::transmute_float_to_int, clippy::transmute_num_to_bytes)]
	fn test_transmute() {
		use crate::transmute;
		use std::mem;

		unsafe {
			assert_eq!(
				transmute::transmute::<f32, i32>(420.69),
				mem::transmute::<f32, i32>(420.69)
			);

			assert_eq!(
				transmute::transmute::<u32, i32>(0xf0000000),
				mem::transmute::<u32, i32>(0xf0000000)
			);

			assert_eq!(
				transmute::transmute::<f64, [u8; 8]>(123.456),
				mem::transmute::<f64, [u8; 8]>(123.456)
			);

			let my_ref = &42;
			assert_eq!(
				transmute::transmute::<&u8, isize>(my_ref),
				mem::transmute::<&u8, isize>(my_ref)
			);

			assert_eq!(
				transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]),
				mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5])
			);

			assert_eq!(
				transmute::transmute::<bool, u8>(true),
				mem::transmute::<bool, u8>(true)
			);

			let my_struct = MyStruct {
				field: true,
				field2: 16,
				field3: "MyStruct's String".into(),
				field4: "MyStruct's &str",
			};
			println!("{my_struct:?}");
			let other_struct_transmute: OtherStruct = transmute(my_struct.clone());
			let other_struct_cast: OtherStruct = my_struct.clone().cast();
			assert_eq!(my_struct, other_struct_transmute);
			assert_eq!(my_struct, other_struct_cast);
		}
	}
}
