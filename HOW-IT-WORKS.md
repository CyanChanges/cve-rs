*Note: The following is no longer part of The Funny:tm:. It's serious and technical. Read at your own discretion.*

# Table of Contents:

Note: Please read the lifetime expansion section first. The other bugs all rely on it.

- [Table of Contents:](#table-of-contents)
- [Lifetime Expansion](#lifetime-expansion)
- [Segfaulting](#segfaulting)


# Lifetime Expansion

All of this starts with a bug that has existed in the Rust compiler for several years now, which allows us to create
a dangling reference:

https://github.com/rust-lang/rust/issues/25860

This bug is **crucial** to cve-rs. It allows us to cast any lifetime to `'static`. So we'll start with an explanation
of how this bug works - specifically, this (moderately terrifying) function:

```rs
fn foo<'a, 'b, T>(_: &'a &'b (), value: &'b T) -> &'a T {
    value
}
```

This function takes two arguments - a double borrow with the lifetimes `&'a &'b`, and single borrow, with the lifetime
`&'b`. It returns the second borrow, but with a lifetime of `'a`, not `'b`. Don't worry about the types of these arguments
for now - let's just look at the lifetimes.

The first argument is a double borrow, and each borrow has a different lifetime. To prevent the creation of a dangling
reference (ironic), the second borrow (`&'b`) must live at least as long as the first borrow (`&'a`). If `'b` did *not*
live as long as `'a`, then `&'a` could borrow dropped data, since the second reference might not exist anymore. This is
the safety rule that Rust will enforce.

Because of this requirement, and because Rust will enforce it, we know that `'b` lives longer than `'a`. This means that
any given `&'b` reference can be converted to `&'a`, since `'b` implicitly lives for as long as `'a`. That makes this entire
function valid - all it does is take `value`, a `&'b` reference, and convert it to an `&'a` reference.

So, basically, this function works because the Rust compiler will always enforce that `'b` outlives `'a`. In theory.

In practice, there's an edge case the compiler *doesn't* detect, which allows us to use that function to convert *any*
lifetime `'b` to some other lifetime `'a` - including `'b` to `'static`. We need a variable to set this up:

```rs
static UNIT: &'static &'static () = &&();
```

This variable doesn't hold any data. All it does is hold two static lifetimes. If combine it with `foo` function above,
`foo` looks like this:

```rs
// The original function for reference
fn foo<'a, 'b, T>(_: &'a &'b (), value: &'b T) -> &'a T {
    value
}

// Lifetimes when we call foo(UNIT, some_other_value) - since we use an `&'static &'static` borrow for the first
// variable, we implicitly set `'a` and `'b` to `'static`.
fn foo<T>(_: &'static &'static (), value: &'static T) -> &'static T {
    value
}
```

Notice that this function now requires `value` to live for `'static`. This prevents really stupid programs like the following:

```rs
static UNIT: &'static &'static () = &&();

fn foo<'a, 'b, T>(_: &'a &'b (), v: &'b T) -> &'a T { v }

// error[E0515]: cannot return value referencing temporary value
// Note: The box here just creates a non-copy type.
fn get_dangling_ref() -> &'static Box<i32> {
    foo(UNIT, &Box::new(42))
}
```

There's Rust's safety guarantees at work. However, if we cast the function's type first, and tell the compiler to figure out the
lifetimes on its own, Rust fails to catch the error:

```rs
static UNIT: &'static &'static () = &&();

fn foo<'a, 'b, T>(_: &'a &'b (), v: &'b T) -> &'a T { v }

fn bad<'c, T>(x: &'c T) -> &'static T {
    // Here we manually cast the function's second argument and return value, which sets `'b` to `'c`, and `'a` to `static`.
    // We then tell the compiler to figure out the lifetimes of the first argument on its own.
    // Rust *should* catch here that `'c` doesn't live for `'static`, but it doesn't. We've now created a function allowing
    // us to cast *any lifetime* `'c` to the permanent lifetime `'static`!
    let f: fn(_, &'c T) -> &'static T = foo;
    f(UNIT, x)
}
```

This is exactly what cve-rs uses in its [lifetime expansion](https://github.com/Speykious/cve-rs/blob/main/src/lifetime_expansion.rs)
module, which powers all of the bugs we have created with it.



# Segfaulting

To segfault, we create a static reference to a box, then immediately drop it:

```rs
fn get_dropped_box() -> &'static Box<()> {
    crate::lifetime_expansion::expand(&Box::new(()))
}
```

Note: Ideally it'd work like this. In practice this never worked unless we created a nested box (`Box<Box<T>>`). Either way
I'll proceed to explain as if it's one box and just assume compiler optimisations caused this issue, because we're not really
sure why this is necessary, to be honest.

What's crucial to understand here is that we have obtained a reference to a box that no longer exists. Under the hood
(from my understanding), the reference is sort of borrowing a location on the stack. Normally, it'd be borrowing the box's
location on the stack, but the box has been popped from the stack:

```rs
fn get_dropped_box() -> &'static Box<()> {
    let my_box: Box<()> = Box::new(());
    // the static reference is valid for the entire program...
    let static_ref_to_box: &'static Box<()> = crate::lifetime_expansion::expand(&my_box);
    // thus the reference is still valid here, despite...
    return static_ref_to_box
    // my_box getting dropped here. When it's dropped it gets popped from the stack, so the reference is borrowing random data.
}
```

So when we later push some values onto the stack, they will overwrite where `my_box` used to be, and our reference will end
up borrowing that data instead. This allows us to completely overwrite the box, but still have an immutable reference to it.

Let's look at how boxes work. Two things happen when we create a box: Memory is allocated in the heap (for whatever data the box stores),
and a pointer to that allocated memory is placed on the stack (this is the actual `Box` type you work with in Rust). When you
get data from the box, Rust reads the box's pointer on the stack, and then dereferences it, so it can get the box's allocation from memory.

Since the box has been dropped, its pointer has been removed from the stack. However, the reference assumes that the box's pointer
is still there, since the reference is still valid. This gives us a unique opportunity to *overwrite the box's pointer*, and substitute
our own pointer instead; all we have to do is create a pointer in the box's old location on the stack, and our reference will use start
using that pointer.

Unfortunately, it's pretty much impossible to completely align values on the stack in safe Rust. To get around this, we spam
a bunch of pointers to the stack - the reference will (probably) end up referring to one of them. It's not clean, but it does (mostly)
work, allowing us to artificially create an arbitrary pointer in safe Rust. Then, when we read from the box using our reference, Rust will go
dereference that pointer, allowing us to read from our arbitrary pointer - still in safe Rust.

To cause a segfault, we just have to perform this exploit with a null pointer, which we can do by creating a slice of `0`s on the stack:

```rs
fn main() {
    // Get a reference to a box that doesn't exist anymore.
    let box_ref = get_dropped_box();
    // black_box disables optimisations. This will hopefully force Rust to put all the 0s in this slice on the stack.
    black_box([0; 1024]);
    // Read from our box, forcing Rust to read and dereference the box's pointer from the stack, which now dereferences a null pointer.
    // Dereferencing a null pointer always causes a segfault.
    *box_ref;
}
```
